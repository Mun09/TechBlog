---
description: 7장 내용 요약
---

# 7장: 스프링부트와 MVC

**서블릿 컨테이너란?**&#x20;

서블릿 컨테이너는 http 메시지를 Java 어플리케이션이 이해할 수 있는 방식으로 변환하는 역할을 한다. 이를 통해서 Java 애플리케이션이 통신계층을 직접 구현하지 않아도 된다. \
ex) tomcat, jetty, jboss, payara, etc

**서블릿이란?**&#x20;

서블릿은 서블릿 컨테이너와 직접 상호작용하는 자바 객체다.

즉 서블릿 컨테이너는 다음의 것들을 처리하게 된다.

1. 클라이언트의 http 요청 수신.
2. 요청을 적절한 서블릿으로 전달.
3. 서블릿의 응답 데이터를 클라이언트에게 전송.

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption><p>figure 7.6</p></figcaption></figure>



**스프링부트는 왜 등장했을까?**&#x20;

스프링으로 웹 앱을 개발하려면 서블릿 컨테이너를 구성하고 클라이언트 요청이 올바르게 서블리과 연결되도록 설정하는 등 많은 시간을 소모했어야 했고 부담스러운 작업이었다.

스프링부트는 개발의 효율성을 극대화하는 도구이며, 개발자들이 비지니스 로직에 집중할 수 있게 해준다.



**스프링 부트의 주요 특징**

1. 프로젝트 생성 간소화 프로젝트 초기화 서비스가 있어서 기본 설정이 완료된 스켈레톤 프로젝트를 빠르게 생성 가능.
2. 의존성 스타터 개발자들이 어떤 의존성이 필요한지 고민하지 않고 스타터만 추가하면 됨. 이는 버전 호환성 문제를 해결하고 안정성을 제공한다.
3. 자동설정 프로젝트에 추가된 의존성을 기반으로 기본적인 설정을 자동으로 정의해줘서 코드량 감소.

이러한 점들 덕분에 스프링부트는 서비스지향아키텍쳐(SOA)와 마이크로서비스 환경에 매우 적합하다.



**의존성 스타터란?**&#x20;

특정 기능에 맞는 호환가능한 의존성들의 그룹

의존성 스타터 덕분에 일일이 필요한 의존성들을 버전에 맞게 추가할 필요가 없어졌다. 스프링부트가 알아서 적절한 버전으로 다운로드해준다. External Libraries를 확인해보자.



**자동 구성(Auto-configuration) 기능**&#x20;

스프링 부트는 "Convention over Configuration" 원칙에 따라서 자동구성 기능도 제공한다. \
단지 프로젝트를 다운받고 ide를 켰을 뿐이지만 Tomcat 인스턴스를 부팅하고 포트 8080번에서 접근 가능하다.

즉 스프링부트는 추가된 의존성을 기반으로 기본적인 구성을 제공한다. \
예를 들어서 web 의존성을 추가하면 서블릿 컨테이너가 필요하다는 것을 스프링이 알고 Tomcat 인스턴스를 기본값으로 설정해주는 것이다. \
이처럼 스프링부트에서는 Tomcat이 서블릿 컨테이너의 관례를 나타낸다.



**Convention over Configuraiton: 관례보다 구성**&#x20;

관례란 특정 목적에 따라 앱을 설정하는 가장 일반적인 방법이다. \
스프링부트는 관례를 기반으로 앱을 구성하며, 개발자가 앱에 요구하는 더 특별한 설정은 필요한 부분만 수정하면 된다. 이런 원칙을 통해서 코드량을 획기적으로 줄일 수 있다.



단순히 tomcat 서버만을 시작하는 것은 웹 앱이 아니다. \
이제 웹 브라우저를 통해 접근할 수 있는 웹 페이지를 구현해야 한다.

1. 브라우저에 표시하고자 하는 컨텐츠가 포함된 html 문서를 작성한다.
2. 생성한 웹 페이지를 위한 액션이 포함된 컨트롤러를 작성한다.

첫번째 단계에서 만든 html문서는 resources/static 폴더에 넣어둔다. \
두번째 단계에서는 http 요청을 앱의 응답으로 제공할 페이지와 연결하는 메서드를 포함하는 컨드롤러를 작성한다. 컨트롤러는 특정 http요청에 대해 실행되는 메서드(또는 액션)을 포함하는 웹 앱의 구성요소이다. \
@Controller 주석을 통해서 해당 클래스를 컨트롤러로 표시한다. \
컨트롤러 주석은 스테레오 타입 주석이므로 빈으로 추가될 것이다. \
클래스 안에 http 요청과 연결된 메서드를 정의할 수 있다. \
메서드는 @RequestMapping("/home") 과 같이 경로를 주석의 값으로 지정함으로서 브라우저가 경로에 엑세스할 때 로직을 처리할 수 있다.



전반적으로 스프링 mvc가 http 요청을 어떻게 처리하는지 살펴보겠다.

1. 클라이언트가 http요청을 웹 브라우저를 통해서 생성한다.
2. Tomcat이 클라이언트의 http요청을 수신한다. \
   Tomcat은 이를 처리하기 위해서 서블릿 컴포넌트를 호출하고, 이 경우 spring mvc는 Dispatcher servlet을 호출한다.
3. Dispatcher servlet은 프론트 컨트롤러라고도 부른다. \
   요청에 대해 호출할 컨트롤러 액션을 찾거나 클라이언트에게 반환할 응답을 관리하는 역할을 한다.
4. Dispatcher Servlet은 요청을 처리할 적절한 컨트롤러 액션을 찾기 위해서 Handler Mapping 컴포넌트에게 위임한다. \
   이 컴포넌트는 액션을 @RequestMapping 주석을 기반으로 탐색한다. \
   (하지만 사실 Handler Mapping은 HTTP 요청 경로뿐만 아니라 HTTP 메서드라는 요소를 기준으로도 검색한다. 나중에 자세히 다룸)
5. Handler Mapping이 액션을 찾지 못하면 앱은 클라이언트에게 "404 Not Found"응답을 보낸다. \
   만약찾는다면 서블릿은 해당 액션을 호출한다. \
   컨트롤러는 응답으로 렌더링할 html 페이지의 이름(View)를 서블릿에게 반환한다.
6. 서블릿은 View Resolver에게 컨트롤러에게서 받은 View 이름을 기반으로 해당 View 이름을 찾도록 한다. View Resolver는 View 이름을 html 파일로 매핑해서 렌더링 가능한 컨텐츠를 생성한다.
7. 렌더링된 View를 받은 Dispatcher Servlet은 http 응답으로 클라이언트에게 반환한다. \
   이제 클라이언트는 브라우저를 통해서 요청된 페이지를 볼 수 있다.



<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption><p>figure 7.18 스프링 MVC의 개략도</p></figcaption></figure>

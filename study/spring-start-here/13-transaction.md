# 13장: Transaction 처리

예를 들어 john이 jane에게 100달러를 주고 싶다고 가정하자. 다음의 단계를 거친다.

1. john의 잔고에서 100달러 차감
2. jane의 잔고에서 100달러 추가

이때 둘 중 하나라도 잘못되면 안된다. \
즉 transaction에서 모든 단계가 성공하거나 모든 단계가 실패해야만 하며 그렇지 않으면 data incosistency가 발생한다. 이를 atomicity라고 한다.

**COMMIT**: 트랜잭션이 성공적으로 종료되고, 애플리케이션이 해당 트랜잭션의 변경 가능한 작업(mutable operations)으로 인해 발생한 모든 변경 사항을 저장되었다. \
**ROLLBACK**: 트랜잭션이 롤백으로 종료될 때, 애플리케이션이 데이터를 트랜잭션 시작 전의 상태로 복원하다.

**스프링에서 트랜젝션은 어떻게 동작하는가?** \
스프링 트랜잭션의 배후에는 스프링 AOP의 Aspect이 존재한다. 스프링이 트랜젝션으로 감싸길 원하는 메소드를 표시하기 위해서 @Transactional 주석을 사용한다. 배후에서 스프링은 aspect를 구성하고 트랜젝션 로직을 적용한다. 일일이 메서드에 주석 붙이기 귀찮으면 클래스위에 붙여서 모든 메서드를 트랙젝션 메서드로 만들수 있다.

이 때문에 트랙젝션 메소드 안에서 따로 예외처리를 하면 aspect에서 예외를 잡아낼 수 없기 때문에 롤백을 할 수 없다. 그럼 런타임에서 일어나는 예외가 아니라 컴파일 과정에서 일어나는 checked exception도 잡아내는가? 데이터 불일치가 아니라 개발자의 제어 실패이므로 기본적으로 예외처리가 이뤄지지 않지만 따로 설정해주면 가능하긴하다.

아래는대략적인 앱의 클래스 설계

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

